最大子数组和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
正确的子问题定义
子问题  表示「nums[0..k) 中，以最后一个元素结尾的最大子数组和」。
既然子数组拼接不起来，那么我们就限制子问题计算的子数组只能位于数组尾部。这样得到的最大和子数组，就一定可以跟下一个元素拼接起来了。
f(4)这时候求的是 [-1, 2, 3, - 2] 中位于数组尾部的最大子数组和，结果是 [2, 3, -2]，和为 3。
计算 f(5)的时候，直接把新元素 4 跟前面的最优解 [2, 3, -2] 拼接起来，得到最大和子数组是 [2, 3, -2, 4]，和为 7。
子问题的递推关系
正确定义了子问题，就可以写出子问题的递推关系了。我们用  表示元素 nums[i]，写出的子问题递推公式为：
这个递推公式的含义是，计算 nums[0..k) 的最大子数组和时，要么是把新元素 nums[k-1] 加入前一个子问题的结果（即  的含义），要么是只使用元素 nums[k-1]，选择其中结果较大的一个方案。
这个递推公式可以继续化简为：f(k)=max(f(k-1),0)+n(k-1)

对应的java代码：
public int maxSubArray(int[] nums) {
    // 子问题：
    // f(k) = nums[0..k) 中以 nums[k-1] 结尾的最大子数组和
    // 原问题 = max{ f(k) }, 0 <= k <= N
    // f(0) = 0
    // f(k) = max{ f(k-1), 0 } + nums[k-1]
 int N = nums.length;
 int[] dp = new int[N+1];
 dp[0] = 0;
 int res = Integer.MIN_VALUE;
    for (int k = 1; k <= N; k++) {
        dp[k] = Math.max(dp[k-1], 0) + nums[k-1];
        res = Math.max(res, dp[k]);
    }
    return res;
}
